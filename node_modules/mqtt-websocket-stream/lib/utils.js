'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var toAsyncFactory = exports.toAsyncFactory = function toAsyncFactory(socketOrFactory) {
  var continueWithError = function continueWithError(error) {
    return function (callback) {
      return process.nextTick(function () {
        return callback(error);
      });
    };
  };
  var continueWithValue = function continueWithValue(value) {
    return function (callback) {
      return process.nextTick(function () {
        return callback(null, value);
      });
    };
  };
  var invalidArgsError = new Error("Must call createStream with a socket or factory function");
  if (!socketOrFactory) return continueWithError(invalidArgsError);
  if ((typeof socketOrFactory === 'undefined' ? 'undefined' : _typeof(socketOrFactory)) === 'object') return continueWithValue(socketOrFactory);
  if (typeof socketOrFactory === 'function' && socketOrFactory.length === 0) return continueWithValue(socketOrFactory()); // for sync functions
  if (typeof socketOrFactory === 'function' && socketOrFactory.length > 0) return socketOrFactory;
  return continueWithError(invalidArgsError);
};

var concatChunks = exports.concatChunks = function concatChunks(chunks) {
  //chunks ::  [{ chunk: ..., encoding: ... }]
  var toBuffer = function toBuffer(chunk, encoding) {
    return encoding === 'utf8' ? Buffer.from(chunk, 'utf8') : chunk;
  };
  var buffers = chunks.map(function (c) {
    return toBuffer(c.chunk, c.encoding);
  });
  return Buffer.concat(buffers);
};

var isBrowserSocket = exports.isBrowserSocket = function isBrowserSocket(socket) {
  return socket.send.length === 1; // send is sync in browser and async with length 3 on server using 'ws' module
};

var initWebSocket = exports.initWebSocket = function initWebSocket(stream, socket) {
  // if (isBrowserSocket(socket)) {
  // }
  socket.binaryType = 'arraybuffer';
  socket.onopen = openHandler(stream);
  socket.onclose = closeHandler(stream);
  socket.onerror = errorHandler(stream);
  socket.onmessage = messageHandler(stream);

  stream.on('finish', streamFinishHandler(socket));
  stream.on('close', streamCloseHandler(socket));
  return socket;
};

var closeStreamWithError = exports.closeStreamWithError = function closeStreamWithError(stream, err) {
  stream.emit('error', err);
  stream.emit('close');
};

var openHandler = function openHandler(stream) {
  return function (evt) {
    stream.emit('connect');
  };
};

var closeHandler = function closeHandler(stream) {
  return function (evt) {
    // const { code, reason, wasClean } = evt
    stream.emit('close'); // as a Readable, when socket is closed, indicate to consumers no more data is coming
  };
};

var errorHandler = function errorHandler(stream) {
  return function (err) {
    stream.emit('error', err);
  };
};

var messageHandler = function messageHandler(stream) {
  var toBuffer = function toBuffer(b) {
    return Buffer.isBuffer(b) ? b : new Buffer(b);
  };

  return function (evt) {
    stream.push(toBuffer(evt.data));
  };
};
var streamFinishHandler = function streamFinishHandler(socket) {
  return function () {
    if (socket.readyState === socket.OPEN) {
      socket.close();
    }
  };
};
var streamCloseHandler = function streamCloseHandler(socket) {
  return function () {
    if (socket.readyState === socket.OPEN) {
      socket.close();
    }
  };
};